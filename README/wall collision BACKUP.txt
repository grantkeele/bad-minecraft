// Wall collision, detects intersection between the player's radius and all 24 of the surrounding blocks
	let thirdStep = getNStep(playerVel.scale(delta), 3);
	
    for (let y = -2; y <= 0; y++) {

        for (let x = -1; x <= 1; x++) {

            for (let z = -1; z <= 1; z++) {

                // Ignore the block that the player is inside of
                if (x === 0 && z === 0) {
                    continue;
                }
				
				let thisBlock = GetBlockData(x + currBlock.x, y + currBlock.y, z + currBlock.z);

                if (thisBlock !== 0 && !liquidList.includes(thisBlock)) {
                    let circlePos = new BABYLON.Vector2(cam.Position.x, cam.Position.z);
                    let squarePos = new BABYLON.Vector2(x + currBlock.x, z + currBlock.z);

                    let isIntersecting = circleSquareIntersect(circlePos, playerRadius, squarePos, 0.5);
                    if (isIntersecting === true) {
                        // Push player in the opposite direction of the intersecting block, snapping their position to lie on the edge of the block.
                        // Three cases: column (x = 0), row (z = 0), or corners (neither x nor z = 0)
                        let newPos = new BABYLON.Vector3(0, 0, 0);

                        if (x === 0) {
                            newPos = new BABYLON.Vector3(
                                cam.Position.x,
                                cam.Position.y,
                                squarePos.y - (z * (0.5 + playerRadius))
                            );
                        }
                        else if (z === 0) {
                            newPos = new BABYLON.Vector3(
                                squarePos.x - (x * (0.5 + playerRadius)),
                                cam.Position.y,
                                cam.Position.z
                            );
                        }
                        else {
                            newPos = new BABYLON.Vector3(
                                squarePos.x - (x * (0.5 + playerRadius)),
                                cam.Position.y,
                                squarePos.y - (z * (0.5 + playerRadius))
                            );
                        }
                        

                        moveCameraToPosition(cam, newPos);

                        console.log('collided with wall');
                        //breakOut = true;
                    }
                }
            }
        }
    }
	

let thirdStep = getNStep(playerVel.scale(delta), 3);
	
	for (let step = 0; step < 3; step++){
		for (let y = -2; y <= 0; y++) {
			
			let thisPos = cam.Position + step;
			let thisBlock = GetBlockData(Math.round(thisPos.x), Math.round(thisPos.y) + y, Math.round(thisPos.z));
			
			if (thisBlock !== 0 && !liquidList.includes(thisBlock)) {
				let circlePos = new BABYLON.Vector2(cam.Position.x, cam.Position.z);
				let squarePos = new BABYLON.Vector2(x + currBlock.x, z + currBlock.z);

				let isIntersecting = circleSquareIntersect(circlePos, playerRadius, squarePos, 0.5);
				if (isIntersecting === true) {
					// Push player in the opposite direction of the intersecting block, snapping their position to lie on the edge of the block.
					// Three cases: column (x = 0), row (z = 0), or corners (neither x nor z = 0)
					let newPos = new BABYLON.Vector3(0, 0, 0);

					if (x === 0) {
						newPos = new BABYLON.Vector3(
							cam.Position.x,
							cam.Position.y,
							squarePos.y - (z * (0.5 + playerRadius))
						);
					}
					else if (z === 0) {
						newPos = new BABYLON.Vector3(
							squarePos.x - (x * (0.5 + playerRadius)),
							cam.Position.y,
							cam.Position.z
						);
					}
					else {
						newPos = new BABYLON.Vector3(
							squarePos.x - (x * (0.5 + playerRadius)),
							cam.Position.y,
							squarePos.y - (z * (0.5 + playerRadius))
						);
					}
					

					moveCameraToPosition(cam, newPos);

					console.log('collided with wall');
					//breakOut = true;
				}
			}
		}
	}